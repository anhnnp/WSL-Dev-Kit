<?php
declare(strict_types=1);

session_start();
require __DIR__ . '/lib.php';

$action = $_GET['a'] ?? 'home';

function flash_set(string $key, string $val): void {
  $_SESSION['flash'][$key] = $val;
}
function flash_get(string $key): string {
  $v = $_SESSION['flash'][$key] ?? '';
  unset($_SESSION['flash'][$key]);
  return (string)$v;
}

function page(string $title, string $bodyHtml): void {
  echo "<!doctype html><html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>";
  echo "<title>" . h($title) . "</title>";
  echo "<style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;max-width:1100px;margin:24px auto;padding:0 12px}
    header{display:flex;justify-content:space-between;align-items:center;margin-bottom:18px;gap:10px}
    table{width:100%;border-collapse:collapse}
    th,td{border:1px solid #ddd;padding:10px;vertical-align:top}
    th{background:#f7f7f7;text-align:left}
    input,select{padding:9px;width:100%;box-sizing:border-box}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px}
    .btn{display:inline-block;padding:9px 12px;border:1px solid #222;background:#222;color:#fff;text-decoration:none;border-radius:8px;cursor:pointer}
    .btn2{display:inline-block;padding:9px 12px;border:1px solid #222;background:#fff;color:#222;text-decoration:none;border-radius:8px}
    .danger{border-color:#b00020;background:#b00020;color:#fff}
    .muted{color:#666}
    .card{border:1px solid #ddd;border-radius:12px;padding:14px;margin:12px 0}
    pre{background:#0b1020;color:#e8e8e8;padding:12px;border-radius:10px;overflow:auto}
    code{background:#f3f3f3;padding:2px 6px;border-radius:6px}
    .ok{color:#0b7a31}
    .bad{color:#b00020}
    .warn{color:#8a6a01}
    details summary{cursor:pointer}
  </style></head><body>";

  echo "<header><div><strong>VHost Manager (DEV)</strong> <span class='muted'>| WSL2 Ubuntu 22.04 | Nginx + PHP-FPM</span></div>";
  echo "<div>";
  echo "<a class='btn2' href='?a=home'>Danh sách</a> ";
  echo "<a class='btn2' href='?a=create'>Tạo website</a>";
  echo "</div></header>";

  echo $bodyHtml;
  echo "</body></html>";
}

/**
 * Helper: build base URL for the current app (works for root or subfolder deployment)
 */
function current_base_url(): string {
  $isHttps = (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off')
    || (isset($_SERVER['SERVER_PORT']) && (int)$_SERVER['SERVER_PORT'] === 443);

  $scheme = $isHttps ? 'https' : 'http';
  $host = $_SERVER['HTTP_HOST'] ?? 'localhost';
  $scriptName = $_SERVER['SCRIPT_NAME'] ?? '/index.php';
  $basePath = rtrim(str_replace('\\', '/', dirname($scriptName)), '/');
  if ($basePath === '') $basePath = '';

  return "{$scheme}://{$host}{$basePath}";
}

/**
 * ACTION: export enabled domains as JSON
 */
if ($action === 'export-domains') {
  header('Content-Type: application/json; charset=utf-8');

  $rows = db()->query("SELECT domain FROM sites WHERE enabled=1 ORDER BY domain ASC")
    ->fetchAll(PDO::FETCH_COLUMN);

  echo json_encode([
    'tag' => 'wsl-vhost-manager',
    'domains' => $rows,
    'generated_at' => now_iso(),
  ], JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE);

  exit;
}

/**
 * ACTION: download Windows hosts sync script (.ps1)
 */
/**
 * ACTION: download Windows hosts sync script (.ps1)
 * Embed domains from DB at download time (no HTTP call on Windows)
 */
if ($action === 'download-sync-script') {

  // 1) Fetch enabled domains
  $rows = db()->query("SELECT domain FROM sites WHERE enabled=1 ORDER BY domain ASC")
    ->fetchAll(PDO::FETCH_COLUMN);

  $domains = [];
  foreach ($rows as $d) {
    $d = trim((string)$d);
    if ($d === '') continue;
    $domains[] = $d;
  }

  // 2) Build PowerShell array literal: @("a","b")
  // PowerShell double-quoted strings escape by doubling quotes.
  $psDomains = '@(' . implode(', ', array_map(function($s) {
    $s = str_replace('"', '""', $s);
    return '"' . $s . '"';
  }, $domains)) . ')';

  $generatedAt = date('c');

  // 3) NOWDOC template (no PHP variable interpolation at all)
  $ps1 = <<<'PS1'
#requires -runasadministrator
<#
  WSL VHost Manager - Sync Windows hosts (BULLETPROOF + CFA AWARE)
  Generated by vhost-manager on: __GENERATED_AT__

  New logic:
  - Domains are embedded at download time from DB (enabled sites).
  - No HTTP call is performed from Windows.

  Safety guarantees:
  - Never truncates hosts directly
  - Always creates timestamped backup first
  - Writes to a temp file, validates, then replaces
  - Uses FileStream/.NET write (more robust than Set-Content)
  - Retries if file is temporarily locked
  - Rolls back on any failure
  - Uses named mutex to prevent concurrent runs

  CFA (Controlled Folder Access) support:
  - Detects CFA state and warns
  - If CFA is enabled, tries to temporarily disable, then restore original state
#>

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# ===================== CONFIG =====================
$HostsPath       = Join-Path $env:WINDIR "System32\drivers\etc\hosts"

$Begin   = "# --- BEGIN WSL VHOST MANAGER (WSL Ubuntu) ---"
$End     = "# --- END WSL VHOST MANAGER ---"
$LineTag = "# wsl-vhost-manager"

# Change if needed
$TargetIp = "127.0.0.1"

# Embedded domains from DB (enabled=1) at download time:
$domains = __DOMAINS_ARRAY__

# Backups stored alongside hosts
$BackupDir = Split-Path -Parent $HostsPath

# Concurrency + retry tuning
$MutexName          = "Global\WSL_VHOST_MANAGER_SYNC_HOSTS_MUTEX"
$MutexTimeoutMs     = 15000
$WriteRetryCount    = 12
$WriteRetryDelayMs  = 250

# ===================== OUTPUT HELPERS =====================
function Write-Info([string]$msg) { Write-Host $msg -ForegroundColor Cyan }
function Write-Warn([string]$msg) { Write-Host $msg -ForegroundColor Yellow }
function Write-Err ([string]$msg) { Write-Host $msg -ForegroundColor Red }

# ===================== CFA (Controlled Folder Access) =====================
# CFA states commonly:
# 0 = Disabled, 1 = Enabled, 2 = Audit Mode
$script:CfaOriginal = $null
$script:CfaTemporarilyChanged = $false

function Get-CfaState {
  try {
    $cmd = Get-Command Get-MpPreference -ErrorAction Stop
    if ($null -ne $cmd) {
      $pref = Get-MpPreference
      return $pref.EnableControlledFolderAccess
    }
  } catch { }
  return $null
}

function Set-CfaState([int]$state) {
  # Requires admin + Defender; may be blocked by policy/EDR
  Set-MpPreference -EnableControlledFolderAccess $state -ErrorAction Stop
}

function Maybe-DisableCfaForWrite {
  $state = Get-CfaState

  if ($null -eq $state) {
    Write-Warn "CFA check: Cannot read Defender CFA state (Get-MpPreference unavailable). If writes fail, check Windows Security > Ransomware protection."
    return
  }

  $script:CfaOriginal = [int]$state

  if ($script:CfaOriginal -eq 1) {
    Write-Warn "WARNING: Controlled Folder Access (CFA) is ENABLED. This may block writing to hosts."
    try {
      Write-Info "Attempting to temporarily DISABLE CFA for this run..."
      Set-CfaState 0
      $script:CfaTemporarilyChanged = $true
      Write-Info "CFA temporarily disabled."
    } catch {
      Write-Warn "Could not disable CFA (policy/EDR may block). Error: $($_.Exception.Message)"
    }
  }
  elseif ($script:CfaOriginal -eq 2) {
    Write-Warn "CFA is in AUDIT mode (2). Usually should not block, but some setups still interfere."
  }
  else {
    Write-Info "CFA is disabled (0)."
  }
}

function Restore-CfaIfChanged {
  if ($script:CfaTemporarilyChanged -and $null -ne $script:CfaOriginal) {
    try {
      Write-Info "Restoring CFA to original state ($script:CfaOriginal)..."
      Set-CfaState $script:CfaOriginal
      Write-Info "CFA restored."
    } catch {
      Write-Warn "Failed to restore CFA. Please re-check Windows Security > Ransomware protection. Error: $($_.Exception.Message)"
    }
  }
}

# ===================== CORE HELPERS =====================
function Ensure-HostsFileExists {
  if (-not (Test-Path -LiteralPath $HostsPath)) {
    throw "Hosts file not found at: $HostsPath"
  }
}

function Read-HostsRaw {
  try {
    return Get-Content -LiteralPath $HostsPath -Raw -ErrorAction Stop
  } catch {
    throw "Cannot read hosts file at $HostsPath. Error: $($_.Exception.Message)"
  }
}

function Build-ManagedBlock([string[]]$domains) {
  $lines = New-Object System.Collections.Generic.List[string]
  $lines.Add($Begin)

  foreach ($d in $domains) {
    if ([string]::IsNullOrWhiteSpace($d)) { continue }
    $domain = $d.Trim()
    if ($domain -match '\s' -or $domain.StartsWith("#")) { continue }
    $lines.Add(("{0}`t{1}`t{2}" -f $TargetIp, $domain, $LineTag))
  }

  $lines.Add($End)
  return ($lines -join "`r`n") + "`r`n"
}

function Remove-ExistingManagedBlock([string]$hostsContent) {
  $pattern = [regex]::Escape($Begin) + ".*?" + [regex]::Escape($End) + "\s*"
  return [regex]::Replace($hostsContent, $pattern, "", "Singleline")
}

function Ensure-TrailingCrLf([string]$text) {
  if ([string]::IsNullOrEmpty($text)) { return "`r`n" }
  if (-not $text.EndsWith("`r`n")) { return $text + "`r`n" }
  return $text
}

function Backup-HostsFile {
  $stamp = Get-Date -Format "yyyyMMdd_HHmmss"
  $backupPath = Join-Path $BackupDir ("hosts.bak_{0}" -f $stamp)
  Copy-Item -LiteralPath $HostsPath -Destination $backupPath -Force -ErrorAction Stop
  return $backupPath
}

function Cleanup-BackupFile([string]$backupPath) {
  if ([string]::IsNullOrWhiteSpace($backupPath)) { return }
  try {
    if (Test-Path -LiteralPath $backupPath) {
      Remove-Item -LiteralPath $backupPath -Force -ErrorAction Stop
      Write-Info "Cleanup: removed backup $backupPath"
    }
  } catch {
    Write-Warn "Cleanup: could not remove backup $backupPath. Error: $($_.Exception.Message)"
  }
}

function Write-AllBytesWithRetry([string]$path, [byte[]]$bytes) {
  $lastError = $null
  for ($i = 1; $i -le $WriteRetryCount; $i++) {
    try {
      $fs = [System.IO.File]::Open($path, [System.IO.FileMode]::Create, [System.IO.FileAccess]::Write, [System.IO.FileShare]::Read)
      try { $fs.Write($bytes, 0, $bytes.Length); $fs.Flush() } finally { $fs.Dispose() }
      return
    } catch {
      $lastError = $_.Exception.Message
      Start-Sleep -Milliseconds $WriteRetryDelayMs
    }
  }
  throw "Failed to write after $WriteRetryCount retries. Last error: $lastError"
}

function Replace-HostsSafely([string]$newContent, [string]$backupPath) {
  $tmp = Join-Path $env:TEMP ("hosts.tmp.{0}" -f [Guid]::NewGuid().ToString("N"))
  try {
    $bytes = [System.Text.Encoding]::ASCII.GetBytes($newContent)
    Write-AllBytesWithRetry -path $tmp -bytes $bytes

    $readBack = Get-Content -LiteralPath $tmp -Raw -ErrorAction Stop
    if ($readBack.Length -lt 20) { throw "Temp validation failed: content too small." }
    if ($readBack -notmatch [regex]::Escape($Begin) -or $readBack -notmatch [regex]::Escape($End)) { throw "Temp validation failed: markers missing." }

    Move-Item -LiteralPath $tmp -Destination $HostsPath -Force -ErrorAction Stop
  } catch {
    Write-Err "Replace failed: $($_.Exception.Message)"
    Write-Warn "Attempting rollback from backup..."
    try {
      Move-Item -LiteralPath $backupPath -Destination $HostsPath -Force -ErrorAction Stop
      Write-Info "Rollback OK: restored from $backupPath"
    } catch {
      throw "Rollback FAILED. Backup is at: $backupPath. Error: $($_.Exception.Message)"
    }
    throw
  } finally {
    if (Test-Path -LiteralPath $tmp) { Remove-Item -LiteralPath $tmp -Force -ErrorAction SilentlyContinue }
  }
}

# ===================== MAIN =====================
$mutex = New-Object System.Threading.Mutex($false, $MutexName)
$hasLock = $false

try {
  $hasLock = $mutex.WaitOne($MutexTimeoutMs)
  if (-not $hasLock) { throw "Could not acquire mutex within $MutexTimeoutMs ms. Another sync may be running." }

  Maybe-DisableCfaForWrite
  Ensure-HostsFileExists

  Write-Info ("Domains: " + ($domains -join ", "))

  $block = Build-ManagedBlock -domains $domains
  $hostsOriginal = Read-HostsRaw
  $hostsBase = Remove-ExistingManagedBlock -hostsContent $hostsOriginal
  $hostsBase = Ensure-TrailingCrLf -text $hostsBase
  $hostsNew  = $hostsBase + $block

  if ([string]::IsNullOrWhiteSpace($hostsNew)) { throw "Refusing to write empty hosts content." }
  if ($hostsNew.Length -lt 20) { throw "Refusing to write: content suspiciously small." }
  if ($hostsNew -notmatch [regex]::Escape($Begin) -or $hostsNew -notmatch [regex]::Escape($End)) { throw "Refusing to write: managed block markers missing." }

  $backupPath = Backup-HostsFile
  Write-Info "Backup created: $backupPath"

  Replace-HostsSafely -newContent $hostsNew -backupPath $backupPath
  Write-Info "OK: hosts updated at $HostsPath"

  # Remove backup after successful update to avoid clutter
  Cleanup-BackupFile -backupPath $backupPath
}
finally {
  Restore-CfaIfChanged
  if ($hasLock) { $mutex.ReleaseMutex | Out-Null }
  $mutex.Dispose()
}
PS1;

  // 4) Inject placeholders
  $ps1 = str_replace('__GENERATED_AT__', $generatedAt, $ps1);
  $ps1 = str_replace('__DOMAINS_ARRAY__', $psDomains, $ps1);

  // 5) Output as a clean file; prevent HTML warnings from polluting file
  // You SHOULD also disable display_errors for this route in production.
  @ini_set('display_errors', '0');

  $filename = "sync-windows-hosts.ps1";
  if (ob_get_length()) { ob_end_clean(); }
  header('Content-Type: application/octet-stream');
  header('Content-Disposition: attachment; filename="'.$filename.'"');
  header('Content-Length: ' . strlen($ps1));
  echo $ps1;
  exit;
}

/**
 * HOME
 */
if ($action === 'home') {
  $rows = db()->query("SELECT * FROM sites ORDER BY id DESC")->fetchAll(PDO::FETCH_ASSOC);

  $msg = flash_get('msg');
  $log = flash_get('log');

  $html = "<div class='card'>
    <h2>Websites</h2>
    <p class='muted'>
      Create/Save sẽ tự tạo vhost + enable/disable + add/remove /etc/hosts + nginx -t + reload nginx + reload PHP-FPM.
      <br>Tip: domain dev nên dùng <code>.test</code> hoặc <code>.local</code>.
    </p>
    ".($msg ? "<p><strong>".h($msg)."</strong></p>" : "")."
    ".($log ? "<details style='margin-top:10px'><summary>Xem log provisioning</summary><pre>".h($log)."</pre></details>" : "")."
  </div>";

  $html .= "<table><thead><tr>
    <th>ID</th><th>Domain</th><th>PHP</th><th>Source path</th><th>Enabled</th><th>Updated</th><th>Actions</th>
  </tr></thead><tbody>";

  foreach ($rows as $r) {
    $id = (int)$r['id'];
    $domain = $r['domain'];
    $phpv = $r['php_version'];
    $src = $r['source_path'];
    $enabled = (int)$r['enabled'] === 1 ? "<span class='ok'><strong>Yes</strong></span>" : "<span class='bad'><strong>No</strong></span>";

    $url = "http://{$domain}/";
    $html .= "<tr>
      <td>{$id}</td>
      <td><strong>".h($domain)."</strong><br><a href='".h($url)."' target='_blank'>".h($url)."</a></td>
      <td>".h($phpv)."</td>
      <td><code>".h($src)."</code></td>
      <td>{$enabled}</td>
      <td>".h($r['updated_at'])."</td>
      <td>
        <a class='btn2' href='?a=edit&id={$id}'>Sửa</a>
        <a class='btn2 danger' href='?a=delete&id={$id}'>Xoá</a>
      </td>
    </tr>";
  }

  $html .= "</tbody></table>";

  // Helpful WSL hint
  $html .= "
  <div class='card'>
    <h3>WSL lưu ý</h3>
    <p class='muted'>
      App add domain vào <code>/etc/hosts</code> trong WSL. Nếu bạn mở domain bằng browser Windows mà không vào được,
      bạn cần add domain vào file hosts của Windows nữa.
    </p>
  </div>";

  $dl = "?a=download-sync-script";
  $html .= "<div class='card'>
    <h3>Sync Windows hosts (Windows 11)</h3>
    <p class='muted'>
      Tải script PowerShell để update <code>C:\\Windows\\System32\\drivers\\etc\\hosts</code> theo danh sách domain enabled trong WSL.
      Script sẽ ghi vào 1 block có comment BEGIN/END để dễ kiểm tra.
    </p>
    <p>
      <a class='btn2' href='".h($dl)."'>Download sync-windows-hosts.ps1</a> (<a href='/?a=export-domains'>Xem danh sách vhost</a>)
    </p>
    <p class='muted'>
      <ul>
      <li>
      Cách chạy: Right click file <code>.ps1</code> → <strong>Run with PowerShell</strong><br/>
      (hoặc mở PowerShell Admin rồi chạy `<em>powershell -ExecutionPolicy Bypass -File .\sync-windows-hosts.ps1</em>`).
      </li>
      <li>
      Windows đôi khi chặn script tải về. Nếu chạy bị chặn: Right click file → Properties → tick Unblock.<br/>
      Hoặc chạy: `<em>Set-ExecutionPolicy -Scope CurrentUser RemoteSigned</em>`.
      </li>
      </ul>
    </p>
  </div>";

  page("Home", $html);
  exit;
}

/**
 * CREATE (with confirm create dir)
 */
if ($action === 'create') {
  $msg = '';
  $log = '';
  $needCreate = false;
  $needCreatePath = '';

  $defaultPhp = cfg()['default_php_version'] ?? '8.1';
  $serverType = cfg()['default_server_type'] ?? 'nginx';

  $postedDomain = (string)($_POST['domain'] ?? '');
  $postedPhp    = (string)($_POST['php_version'] ?? $defaultPhp);
  $postedSrc    = (string)($_POST['source_path'] ?? '');

  if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    if (!csrf_check($_POST['csrf'] ?? '')) die("CSRF");

    [$okD, $domainOrErr] = validate_domain($postedDomain);
    [$okP, $phpOrErr]    = validate_php_version($postedPhp);

    $rawSource = $postedSrc;
    [$okR, $srcInfoOrErr] = validate_source_path($rawSource);

    if (!$okD) $msg = $domainOrErr;
    elseif (!$okP) $msg = $phpOrErr;
    elseif (!$okR) $msg = $srcInfoOrErr;
    else {
      // validate_source_path trả về array ['status' => 'ok'|'need_create', 'path' => '...']
      $srcStatus = $srcInfoOrErr['status'] ?? 'ok';
      $srcPath   = $srcInfoOrErr['path'] ?? rtrim($rawSource, '/');

      // Nếu cần tạo folder mà chưa confirm
      if ($srcStatus === 'need_create' && empty($_POST['create_dir'])) {
        $needCreate = true;
        $needCreatePath = $srcPath;
        $msg = "⚠️ Thư mục source chưa tồn tại: {$srcPath}. Bạn có muốn tạo tự động (mkdir -p) không?";
      } else {
        // Nếu user confirm tạo folder
        if ($srcStatus === 'need_create' && !empty($_POST['create_dir'])) {
          if (!sudo_can_run($log)) {
            $msg = "❌ Không thể tạo thư mục vì sudo NOPASSWD chưa cấu hình cho user chạy PHP-FPM (thường là www-data).";
          } else {
            $okMk = sudo_mkdir_p($srcPath, $log);
            if (!$okMk) {
              $msg = "❌ Tạo thư mục thất bại. Xem log bên dưới.";
            } else {
              // Re-validate after mkdir
              [$okR2, $srcInfo2] = validate_source_path($srcPath);
              if (!$okR2 || ($srcInfo2['status'] ?? '') !== 'ok') {
                $msg = "❌ Đã tạo thư mục nhưng PHP vẫn không truy cập được (permission/traverse). Xem log.";
              } else {
                $srcPath = $srcInfo2['path'];
              }
            }
          }
        }

        // Nếu không có msg lỗi => tiến hành insert DB + provision
        if ($msg === '') {
          $domain = $domainOrErr;
          $phpv   = $phpOrErr;
          $src    = $srcPath;

          try {
            $now = now_iso();
            $stmt = db()->prepare("INSERT INTO sites(domain, server_type, php_version, source_path, enabled, created_at, updated_at)
                                   VALUES(?,?,?,?,?,?,?)");
            $stmt->execute([$domain, $serverType, $phpv, $src, 1, $now, $now]);

            $site = [
              'domain' => $domain,
              'server_type' => $serverType,
              'php_version' => $phpv,
              'source_path' => $src,
              'enabled' => 1,
            ];

            $ok = provision_site($site, $log);

            if ($ok) {
              flash_set('msg', "✅ Đã tạo & provision thành công: http://{$domain}/");
              flash_set('log', $log);
              header("Location: ?a=home"); exit;
            } else {
              $msg = "❌ Tạo DB OK nhưng provision thất bại. Xem log bên dưới.";
            }

          } catch (Throwable $e) {
            $msg = "Lỗi DB: " . $e->getMessage();
          }
        }
      }
    }
  }

  $phpOptions = "";
  foreach (array_keys(cfg()['php_map']) as $v) {
    $sel = ($postedPhp === $v) ? "selected" : "";
    $phpOptions .= "<option value='".h($v)."' {$sel}>PHP ".h($v)."</option>";
  }

  // Buttons: nếu cần confirm tạo folder => submit lại với create_dir=1
  if ($needCreate) {
    $buttons = "
      <input type='hidden' name='create_dir' value='1'>
      <button class='btn'>Tạo thư mục & tiếp tục</button>
      <a class='btn2' href='?a=create'>Cancel</a>
    ";
  } else {
    $buttons = "
      <button class='btn'>Create & Provision</button>
      <a class='btn2' href='?a=home'>Cancel</a>
    ";
  }

  page("Create", "
    <div class='card'>
      <h2>Tạo website (DEV)</h2>
      ".($msg ? "<p><strong>".h($msg)."</strong></p>" : "")."

      <form method='post'>
        <input type='hidden' name='csrf' value='".h(csrf_token())."'>

        <div class='row'>
          <div>
            <label>Domain</label>
            <input name='domain' placeholder='myapp.test' value='".h($postedDomain)."' required>
          </div>
          <div>
            <label>PHP Version</label>
            <select name='php_version'>{$phpOptions}</select>
          </div>
        </div>

        <div style='margin-top:12px'>
          <label>Source path (DocumentRoot)</label>
          <input name='source_path' placeholder='/home/username/project/public' value='".h($postedSrc)."' required>
          <div class='muted' style='margin-top:6px'>
            Gợi ý: framework có thư mục <code>public</code> thì trỏ vào <code>public</code>.
            ".($needCreate ? "<br><span class='warn'><strong>Chưa tồn tại:</strong> ".h($needCreatePath)."</span>" : "")."
          </div>
        </div>

        <div style='margin-top:12px'>
          {$buttons}
        </div>
      </form>

      ".($log ? "<h3 style='margin-top:14px'>Log</h3><pre>".h($log)."</pre>" : "")."
    </div>
  ");
  exit;
}

/**
 * EDIT (Save auto provision)
 */
if ($action === 'edit') {
  $id = (int)($_GET['id'] ?? 0);
  $stmt = db()->prepare("SELECT * FROM sites WHERE id=?");
  $stmt->execute([$id]);
  $site = $stmt->fetch(PDO::FETCH_ASSOC);
  if (!$site) die("Not found");

  $msg = '';
  $log = '';
  $needCreate = false;
  $needCreatePath = '';

  $postedPhp = (string)($_POST['php_version'] ?? $site['php_version']);
  $postedSrc = (string)($_POST['source_path'] ?? $site['source_path']);
  $postedEn  = (string)($_POST['enabled'] ?? (string)$site['enabled']);

  if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    if (!csrf_check($_POST['csrf'] ?? '')) die("CSRF");

    [$okP, $phpOrErr] = validate_php_version($postedPhp);

    [$okR, $srcInfoOrErr] = validate_source_path($postedSrc);

    if (!$okP) $msg = $phpOrErr;
    elseif (!$okR) $msg = $srcInfoOrErr;
    else {
      $srcStatus = $srcInfoOrErr['status'] ?? 'ok';
      $srcPath   = $srcInfoOrErr['path'] ?? rtrim($postedSrc, '/');

      if ($srcStatus === 'need_create' && empty($_POST['create_dir'])) {
        $needCreate = true;
        $needCreatePath = $srcPath;
        $msg = "⚠️ Thư mục source chưa tồn tại: {$srcPath}. Bạn có muốn tạo tự động (mkdir -p) không?";
      } else {
        if ($srcStatus === 'need_create' && !empty($_POST['create_dir'])) {
          if (!sudo_can_run($log)) {
            $msg = "❌ Không thể tạo thư mục vì sudo NOPASSWD chưa cấu hình cho user chạy PHP-FPM (thường là www-data).";
          } else {
            $okMk = sudo_mkdir_p($srcPath, $log);
            if (!$okMk) {
              $msg = "❌ Tạo thư mục thất bại. Xem log.";
            } else {
              [$okR2, $srcInfo2] = validate_source_path($srcPath);
              if (!$okR2 || ($srcInfo2['status'] ?? '') !== 'ok') {
                $msg = "❌ Đã tạo thư mục nhưng PHP vẫn không truy cập được (permission/traverse). Xem log.";
              } else {
                $srcPath = $srcInfo2['path'];
              }
            }
          }
        }

        if ($msg === '') {
          $enabled = ((int)$postedEn === 1) ? 1 : 0;
          $now = now_iso();

          db()->prepare("UPDATE sites SET php_version=?, source_path=?, enabled=?, updated_at=? WHERE id=?")
            ->execute([$phpOrErr, $srcPath, $enabled, $now, $id]);

          $stmt->execute([$id]);
          $site = $stmt->fetch(PDO::FETCH_ASSOC);

          $ok = provision_site($site, $log);
          if ($ok) {
            flash_set('msg', "✅ Đã lưu & provision thành công: http://{$site['domain']}/");
            flash_set('log', $log);
            header("Location: ?a=home"); exit;
          } else {
            $msg = "❌ Lưu DB OK nhưng provision thất bại. Xem log.";
          }
        }
      }
    }
  }

  $phpOptions = "";
  foreach (array_keys(cfg()['php_map']) as $v) {
    $sel = ($postedPhp === $v) ? "selected" : "";
    $phpOptions .= "<option value='".h($v)."' {$sel}>PHP ".h($v)."</option>";
  }

  $enYes = ((int)$postedEn === 1) ? "selected" : "";
  $enNo  = ((int)$postedEn === 0) ? "selected" : "";

  // Buttons: nếu cần confirm tạo folder => submit lại với create_dir=1
  if ($needCreate) {
    $buttons = "
      <input type='hidden' name='create_dir' value='1'>
      <button class='btn'>Tạo thư mục & tiếp tục</button>
      <a class='btn2' href='?a=edit&id={$id}'>Cancel</a>
    ";
  } else {
    $buttons = "
      <button class='btn'>Save & Provision</button>
      <a class='btn2' href='?a=home'>Back</a>
    ";
  }

  page("Edit", "
    <div class='card'>
      <h2>Sửa: ".h($site['domain'])."</h2>
      ".($msg ? "<p><strong>".h($msg)."</strong></p>" : "")."

      <form method='post'>
        <input type='hidden' name='csrf' value='".h(csrf_token())."'>

        <div class='row3'>
          <div>
            <label>Domain</label>
            <input value='".h($site['domain'])."' disabled>
          </div>
          <div>
            <label>PHP Version</label>
            <select name='php_version'>{$phpOptions}</select>
          </div>
          <div>
            <label>Enabled</label>
            <select name='enabled'>
              <option value='1' {$enYes}>Yes</option>
              <option value='0' {$enNo}>No</option>
            </select>
          </div>
        </div>

        <div style='margin-top:12px'>
          <label>Source path (DocumentRoot)</label>
          <input name='source_path' value='".h($postedSrc)."' required>
          <div class='muted' style='margin-top:6px'>
            ".($needCreate ? "<span class='warn'><strong>Chưa tồn tại:</strong> ".h($needCreatePath)."</span>" : "")."
          </div>
        </div>

        <div style='margin-top:12px'>
          {$buttons}
        </div>
      </form>

      ".($log ? "<h3 style='margin-top:14px'>Log</h3><pre>".h($log)."</pre>" : "")."
    </div>
  ");
  exit;
}

/**
 * DELETE
 */
if ($action === 'delete') {
  $id = (int)($_GET['id'] ?? 0);
  $stmt = db()->prepare("SELECT * FROM sites WHERE id=?");
  $stmt->execute([$id]);
  $site = $stmt->fetch(PDO::FETCH_ASSOC);
  if (!$site) die("Not found");

  $msg = "";
  $log = "";

  if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    if (!csrf_check($_POST['csrf'] ?? '')) die("CSRF");

    $ok = remove_site_provision($site, $log);

    if ($ok) {
      db()->prepare("DELETE FROM sites WHERE id=?")->execute([$id]);
      flash_set('msg', "✅ Đã xoá vhost + remove hosts + xoá record DB. (Không xoá source code)");
      flash_set('log', $log);
      header("Location: ?a=home"); exit;
    } else {
      $msg = "❌ Xoá thất bại. Xem log.";
    }
  }

  page("Delete", "
    <div class='card'>
      <h2>Xoá: ".h($site['domain'])."</h2>
      <p class='muted'>Sẽ remove vhost config + hosts entry. Không xoá thư mục source code.</p>
      ".($msg ? "<p><strong>".h($msg)."</strong></p>" : "")."

      <form method='post'>
        <input type='hidden' name='csrf' value='".h(csrf_token())."'>
        <button class='btn danger'>Confirm Delete</button>
        <a class='btn2' href='?a=home'>Cancel</a>
      </form>

      ".($log ? "<h3 style='margin-top:14px'>Log</h3><pre>".h($log)."</pre>" : "")."
    </div>
  ");
  exit;
}

header("Location: ?a=home"); exit;
